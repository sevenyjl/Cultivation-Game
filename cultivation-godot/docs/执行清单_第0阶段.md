# 第0阶段：执行清单（基线与约束）

参考《docs/代码约定.md》，按以下步骤落地：

## 1) 建立规范
- [x] 新建并阅读《docs/代码约定.md》
- [ ] 将规范链接加入项目 README/重构计划

## 2) 全局扫描与标记
- [ ] 全局搜索 `初始化(`：列出所有定义/调用点，标记“数据绑定/首次渲染/异步加载”的职责类别
- [ ] 全局搜索 `func _process(`：确认哪些必须保留（动画/拖拽），其余改为信号驱动
- [ ] 全局搜索 `pressed.connect(`：检查是否在 `_ready` 绑定、`_exit_tree` 释放
- [ ] 全局搜索 `GameData.mainNode` 和跨 UI 访问：记录耦合点，改为订阅 `GameData` 信号

## 3) 模板替换与接口统一
- [ ] 统一组件接口：将 `初始化(...)` 替换为 `bind(model)`/`unbind()`；首次渲染在 `bind()` 中触发
- [ ] 去掉外部 `await 初始化(...)`，异步加载改为组件内部私有处理
- [ ] 控制器节点负责收集/分发 `bind`，子组件只接收 `bind`

## 4) 事件驱动替换轮询
- [ ] 在模型/Store 增加细粒度信号（如 `player_changed`、`inventory_changed`）
- [ ] UI 订阅后刷新；高频更新改为“脏标记 + Timer 节流（5–10Hz）”

## 5) 数据流边界（Store 化）
- [ ] 约束 UI 仅订阅 `GameData` 的信号/调用其 API，不访问 `mainNode`/其他 UI
- [ ] `GameData` 对外只读 getter + 修改方法；内部发信号

## 6) 连接/释放安全
- [ ] `connect` 集中在 `_ready`，`disconnect` 在 `_exit_tree`/`unbind`
- [ ] 循环批量连接时，先判断 `is_connected`，避免重复

## 7) UI 结构/样式
- [ ] Tab 改造为 `TabContainer` 或 `ButtonGroup` + Theme 状态
- [ ] 自定义样式：仅应用拷贝样式，切换前清理所有覆盖

## 8) 示例优先落地（建议作为模板）
- [ ] `修炼UI`：改为控制器分发 `bind`，去轮询
- [ ] `修仙者信息组件`：纯展示组件，按模板实现 bind/unbind
- [ ] 背包列表：对象池 + 信号驱动刷新

## 9) 验收
- [ ] 搜索 `await 初始化(` 为 0；`_process` 仅剩动画/拖拽
- [ ] UI 不再访问 `mainNode`/其他 UI 实例
- [ ] 切场景/销毁 UI 无重复连接/悬空信号报错
- [ ] 战斗/背包场景帧率稳定、GC 压力降低


